
parser <- argparse::ArgumentParser(
  prog = "read10x",
  description = "read 10x-genomics data generated by cell ranger"
)

parser $ add_argument(
  "-g", dest = "gene", type = "integer", default = 1,
  help = "column of gene names, 1 for ensembl, 2 for names"
)

parser $ add_argument(
  "-b", dest = "barcode", type = "integer", default = 1,
  help = "column of cell barcode table, in nearly all cases should be 1"
)

if (length(vargs) == 0 ||
      (length(vargs) == 1 && (vargs[1] == "-h" || vargs[1] == "--help"))) {
  parser $ print_help()
  stop()
} else {
  pargs <- parser $ parse_args(vargs)
}

if (shared[["is_loaded"]]) {
  cat("data are already loaded in this directory.", crlf)
  stop()
}

if (!shared[["is_reference_assigned"]]) {
  cat("you should assign a reference genome first.", crlf)
  stop()
}

expr_count <- Seurat::Read10X(
  # for gene names; default is 2 (gene symbol), or 1 (ensembl)
  gene.column = pargs $ gene,
  # specify which column of barcodes.tsv to use for cell names
  cell.column = pargs $ barcode,
  data.dir = getwd()
)

# by default, the cell annotation is absent in barcodes.txt.gz. 10x files
# commonly do not contain grouping information. you should manually specify
# and generate them prior to read10x, (by using `group`)

expr_count_rownames <- rownames(expr_count)
expr_count <- as_tibble(expr_count)

if (!is.null(expr_count_rownames)) {
  cat("row names detected: of size", length(expr_count_rownames), crlf)
  print(head(expr_count_rownames))
}

if (!is.null(expr_count |> colnames())) {
  cat("column names:", length(expr_count |> colnames()), crlf)
  print(head(expr_count |> colnames()))
}

gene_map_pivot <- expr_count_rownames
genes <- readRDS("genome.rds")
gene_names <- genes $ name
genes_notfound <- c()
genes_missing <- c()
genes_map <- c() # mapping order to genes
genes_duplicate <- c()
genes_mask <- c() # mapping order to pivot

if (pargs $ gene == 2) {

  # in this case, we will face disturbing naming problems. some of the genes
  # do not have the same name. it should be noted that mitochondrial genes are
  # especially tend to have others names.

  # in the refseq database, mitochondrial gene names are

  mitos_ncbi <- c(
    "COX1", "COX2", "COX3", "ND1", "ND2", "ND3", "ND4L", "ND4", "ND5", "ND6",
    "CYTB", "ATP6", "ATP8"
  )

  mitos_2 <- paste("mt-", mitos_ncbi, sep = "")

  # don't be confused with these cox1/2/3. they represent cytochrome oxidase.
  # the inflammatory cytokine synthase cox-1/2 are officially named
  # prostoglandin endoperoxide synthase 1/2 or ptgs1/2 actually ...

  # for some occasion, they are

  mitos_3 <- c(
    "mt-Co1", "mt-Co2", "mt-Co3",
    "mt-Nd1", "mt-Nd2", "mt-Nd3", "mt-Nd4l", "mt-Nd4", "mt-Nd5", "mt-Nd6",
    "mt-Cytb", "mt-Atp6", "mt-Atp8"
  )

  # where cytochrome-c oxidase can be named mt-co1/2/3 but not cox1/2/3. anyway,
  # these issues suggest that we should use indices as much as possible, since
  # the names are constantly varying. you may encounter false misses when using
  # names to specify genes.

  mitos_id <- c()
  for (m in mitos_ncbi) {
    mitos_id <- c(mitos_id, grep(paste("^", m, "$", sep = ""),
                                 genes $ name))
  }

  for (t in gene_map_pivot) {

    if (is.na(t)) {
      genes_mask <- c(genes_mask, FALSE)
      next
    }

    ids <- grep(paste("^", t, "$", sep = ""),
                genes $ name, ignore.case = TRUE)

    if (startsWith(str_to_lower(t), "mt")) {
      ids <- mitos_id[
        grep(paste("^", t, "$", sep = ""), mitos_2, ignore.case = TRUE)
      ]

      if (length(ids) == 0) ids <- mitos_id[
        grep(paste("^", t, "$", sep = ""), mitos_3, ignore.case = TRUE)
      ]
    }

    if (ids |> length() == 0) {
      genes_notfound <- c(genes_notfound, t)
      genes_mask <- c(genes_mask, FALSE)
    } else if (ids |> length() == 1) {
      genes_map <- c(genes_map, ids)
      genes_mask <- c(genes_mask, TRUE)
    } else {
      genes_map <- c(genes_map, ids[1])
      genes_duplicate <- c(genes_duplicate, ids[2:length(ids)])
      genes_mask <- c(genes_mask, TRUE)
    }
  }
  genes_missing <- setdiff(seq_along(genes), c(genes_map, genes_duplicate))

} else if (pargs $ gene == 1) {

  for (t in gene_map_pivot) {

    if (is.na(t)) {
      genes_mask <- c(genes_mask, FALSE)
      next
    }

    ids <- grep(paste(t, sep = ""), genes $ ensembl, ignore.case = TRUE)
    if (ids |> length() == 0) {
      genes_notfound <- c(genes_notfound, t)
      genes_mask <- c(genes_mask, FALSE)
    } else if (ids |> length() == 1) {
      genes_map <- c(genes_map, ids)
      genes_mask <- c(genes_mask, TRUE)
    } else {
      genes_map <- c(genes_map, ids[1])
      genes_duplicate <- c(genes_duplicate, ids[2:length(ids)])
      genes_mask <- c(genes_mask, TRUE)
    }
  }
  genes_missing <- setdiff(seq_along(genes), c(genes_map, genes_duplicate))

} else {
  cat(crlf, red("error:"), "invalid mapping method!", crlf)
  q(save = "no", status = 1)
}

cat(crlf, genes_map |> length() |> green() |> italic(),
    italic("genes assigned."), crlf)

if (genes_notfound |> length() > 0)
  cat(
    crlf, genes_notfound |> length() |> red() |> italic(),
    italic("genes detected but not found in reference genome.\n   "),
    genes_notfound |> head() |> str_c(collapse = " ") |> red() |> italic(),
    "...", crlf
  )

if (genes_missing |> length() > 0)
  cat(
    crlf, genes_missing |> length() |> yellow() |> italic(),
    italic("genes not detected.\n   "),
    gene_names[genes_missing |> head()] |> str_c(collapse = " ") |> yellow() |> italic(), # nolint
    "...", crlf
  )

if (genes_duplicate |> length() > 0)
  cat(
    crlf, genes_duplicate |> length() |> cyan() |> italic(),
    italic("duplicated genes in the database.\n   "),
    gene_names[genes_duplicate |> head()] |> str_c(collapse = " ") |> cyan() |> italic(), # nolint
    "...", crlf
  )

expr_count <- expr_count[genes_mask, ]
genes_meta <- genes[genes_map, ]

if (nrow(genes_meta) != nrow(expr_count)) {
  cat(crlf, red("error:"), "assertion failed, genes_meta has", nrow(genes_meta),
      "columns, while expr_count has", nrow(expr_count), "columns", crlf)
  q(save = "no", status = 1)
}


fname_sample_meta <- "sample.tsv"

# read the sample data. the id row is required, and must match the header.
sample_meta <- read.delim(fname_sample_meta, sep = "\t", header = TRUE,
                          comment.char = "#")

n_sample <- nrow(sample_meta)
columns <- colnames(expr_count)
sample_columns <- columns
sample_columns <- sample_columns[!duplicated(sample_columns)]

expr_count <- expr_count[, sample_columns]

if (length(sample_columns) != n_sample) {
  cat(crlf, red("error:"), "mismatch between sample config",
      "and real sample columns.", length(sample_columns), "!=", n_sample, crlf)
  q(save = "no", status = 1)
}

if (setdiff(sample_columns, sample_meta $ id) |> length() > 0) {
  cat(crlf, red("error:"), "sample indexes mismatch", crlf)
  q(save = "no", status = 1)
}

ord <- c()
for (cx in sample_columns) {
  id <- which(sample_meta $ id == cx)
  ord <- c(ord, id[1])
}

sample_meta <- sample_meta[ord, ]

# display the final processed data that is capable to form an adequate
# single cell experiment expression matrix.

dir.create("features")

sample_meta <- sample_meta |> tibble()
genes_meta <- genes_meta |> tibble()

saveRDS(sample_meta, "features/samples-meta.rds")
saveRDS(genes_meta, "features/genes-meta.rds")
saveRDS(expr_count, "features/matrix.rds")

cat(crlf, green("successfully saved expression matrix."), crlf)

shared[["counts"]] <- expr_count
shared[["meta_sample_raw"]] <- sample_meta
shared[["meta_gene_raw"]] <- genes_meta
