
parser <- argparse::ArgumentParser(
  prog = "read10x",
  description = "read 10x-genomics data generated by cell ranger"
)

parser $ add_argument(
  "-g", dest = "gene", type = "integer", default = 1,
  help = "column of gene names, 1 for ensembl, 2 for names"
)

parser $ add_argument(
  "-b", dest = "barcode", type = "integer", default = 1,
  help = "column of cell barcode table, in nearly all cases should be 1"
)

if (length(vargs) == 0 ||
      (length(vargs) == 1 && (vargs[1] == "-h" || vargs[1] == "--help"))) {
  parser $ print_help()
  stop()
} else {
  pargs <- parser $ parse_args(vargs)
}

if (shared[["is_loaded"]]) {
  cat("data are already loaded in this directory.", crlf)
  stop()
}

if (!shared[["is_reference_assigned"]]) {
  cat("you should assign a reference genome first.", crlf)
  stop()
}

expr_count <- Seurat::Read10X(
  # for gene names; default is 2 (gene symbol), or 1 (ensembl)
  gene.column = pargs $ gene,
  # specify which column of barcodes.tsv to use for cell names
  cell.column = pargs $ barcode,
  data.dir = getwd()
)

# by default, the cell annotation is absent in barcodes.txt.gz. 10x files
# commonly do not contain grouping information. you should manually specify
# and generate them prior to read10x, (by using `group`)

expr_count_rownames <- rownames(expr_count)
expr_count <- as_tibble(expr_count)

if (!is.null(expr_count_rownames)) {
  cat("row names detected: of size", length(expr_count_rownames), crlf)
  print(head(expr_count_rownames))
}

if (!is.null(expr_count |> colnames())) {
  cat("column names:", length(expr_count |> colnames()), crlf)
  print(head(expr_count |> colnames()))
}

gene_map_pivot <- expr_count_rownames

if (is.na(gene_map_pivot) |> sum() > 0)
  cat(crlf, yellow("the pivot column contains NAs!"), crlf,
      "   contains", red(is.na(gene_map_pivot) |> sum()), "NAs", crlf)

genes <- readRDS("genome.rds")
gene_names <- genes $ gene

genes_notfound <- c()
genes_duplicate <- c()
genes_mask <- c()
genes_map <- c()

if (pargs $ gene == 2) {
  genes_chr <- genes[!genes $ mito, ]

  m <- match(gene_map_pivot, genes_chr $ gene)
  genes_notfound <- gene_map_pivot[is.na(m)] # mito genes should not be found.
  genes_duplicate <- gene_map_pivot[duplicated(m[!is.na(m)])]
  genes_mask <- !is.na(m)
  genes_map <- m[!is.na(m)]

  expr_count_chr <- expr_count[genes_mask, ]
  genes_meta <- genes_chr[genes_map, ]

  # well, entrez contain many NA's, this step will lose too much information
  # and genes! -- found during processing tcr-delta data.
  
  # expr_count_chr <- expr_count_chr[!duplicated(genes_meta $ entrez), ]
  # genes_meta <- genes_meta[!duplicated(genes_meta $ entrez), ]

  # process mitochondrial genes separately

  genes_mito <- genes[genes $ mito, ]
  mmt <- match(gene_map_pivot, genes_mito $ gene)
  if (sum(!is.na(mmt)) == 0) # all the genes not found. suggesting a name error
    mmt <- match(gene_map_pivot, paste("mt-", genes_mito $ gene))
  if (sum(!is.na(mmt)) == 0) # again
    mmt <- match(gene_map_pivot, paste("MT-", genes_mito $ gene))
  if (sum(!is.na(mmt)) == 0) # again
    mmt <- match(gene_map_pivot, paste("Mt-", genes_mito $ gene))
  if (sum(!is.na(mmt)) == 0) # again
    mmt <- match(gene_map_pivot, paste("MT", genes_mito $ gene))
  if (sum(!is.na(mmt)) == 0) # again
    mmt <- match(gene_map_pivot, paste("mt", genes_mito $ gene))
  if (sum(!is.na(mmt)) == 0) # again
    mmt <- match(gene_map_pivot, paste("Mt", genes_mito $ gene))

  mt_mask <- !is.na(mmt)
  mt_map <- mmt[!is.na(mmt)]

  expr_count_mt <- expr_count[mt_mask, ]
  genes_meta_mt <- genes_mito[mt_map, ]

  expr_count_mt <- expr_count_mt[!duplicated(genes_meta_mt $ entrez), ]
  genes_meta_mt <- genes_meta_mt[!duplicated(genes_meta_mt $ entrez), ]

  newfound_name <- gene_map_pivot[mt_mask]

  cat(crlf, yellow("found these mitochondrial genes:"), crlf)
  if (length(newfound_name) > 0) {
    cat("    ")
    print(newfound_name)
  } else {
    cat("   ", red("not a single mitochondrial genes found, check your data!"))
    cat(crlf)
  }

  genes_notfound <- base::setdiff(genes_notfound, newfound_name)
  expr_count <- rbind(expr_count_mt, expr_count_chr)
  genes_meta <- rbind(genes_meta_mt, genes_meta)

} else if (pargs $ gene == 1) {

  dcensem <- decollapse(genes, "ensembl", sep = ";")
  m <- match(gene_map_pivot, dcensem $ ensembl)

  # if the gene mapping is not found in reference, a NA will occur.
  # if duplicate match, the same index is called again.
  # if the reference is duplicated, will only return the first match.

  genes_notfound <- gene_map_pivot[is.na(m)]
  genes_duplicate <- gene_map_pivot[duplicated(m[!is.na(m)])]
  genes_mask <- !is.na(m)
  genes_map <- m[!is.na(m)]

  expr_count <- expr_count[genes_mask, ]
  genes_meta <- dcensem[genes_map, ]

  expr_count <- expr_count[!duplicated(genes_meta $ ensembl), ]
  genes_meta <- genes_meta[!duplicated(genes_meta $ ensembl), ]

} else {
  cat(crlf, red("error:"), "invalid mapping method!", crlf)
  q(save = "no", status = 1)
}

# print duplicated names
dup_name <- genes_meta[duplicated(genes_meta $ gene), ] $ gene |> unique()
dup_name <- genes_meta[
  pull(genes_meta, "gene") %in% dup_name,
  c("gene", "entrez", ".start", ".end", ".strand", ".seqid")
]

if (nrow(dup_name) > 0) {
  cat(crlf, red("these gene names got duplicated!"), crlf, crlf)
  print(dup_name)
}

# print mapping result.
cat(crlf, expr_count |> nrow() |> green() |> italic(),
    italic("genes assigned."), crlf)

if (genes_notfound |> length() > 0)
  cat(
    crlf, genes_notfound |> length() |> red() |> italic(),
    italic("genes detected but not found in reference genome.\n   "),
    genes_notfound |> head() |> str_c(collapse = " ") |> red() |> italic(),
    "...", crlf
  )

if (genes_duplicate |> length() > 0)
  cat(
    crlf, genes_duplicate |> length() |> red() |> italic(),
    italic("genes duplicated.\n   "),
    genes_duplicate |> head() |> str_c(collapse = " ") |> red() |> italic(),
    "...", crlf
  )

if (nrow(genes_meta) != nrow(expr_count)) {
  cat(crlf, red("error:"), "assertion failed, genes_meta has", nrow(genes_meta),
      "columns, while expr_count has", nrow(expr_count), "columns", crlf)
  q(save = "no", status = 1)
}

fname_sample_meta <- "sample.tsv"

# read the sample data. the id row is required, and must match the header.
sample_meta <- read.delim(fname_sample_meta, sep = "\t", header = TRUE,
                          comment.char = "#")

n_sample <- nrow(sample_meta)
columns <- colnames(expr_count)
sample_columns <- columns
sample_columns <- sample_columns[!duplicated(sample_columns)]

expr_count <- expr_count[, sample_columns]

if (length(sample_columns) != n_sample) {
  cat(crlf, red("error:"), "mismatch between sample config",
      "and real sample columns.", length(sample_columns), "!=", n_sample, crlf)
  q(save = "no", status = 1)
}

if (setdiff(sample_columns, sample_meta $ id) |> length() > 0) {
  cat(crlf, red("error:"), "sample indexes mismatch", crlf)
  q(save = "no", status = 1)
}

ord <- c()
for (cx in sample_columns) {
  id <- which(sample_meta $ id == cx)
  ord <- c(ord, id[1])
}

sample_meta <- sample_meta[ord, ]

# display the final processed data that is capable to form an adequate
# single cell experiment expression matrix.

dir.create("features")

sample_meta <- sample_meta |> tibble()
genes_meta <- genes_meta |> tibble()

saveRDS(sample_meta, "features/samples-meta.rds")
saveRDS(genes_meta, "features/genes-meta.rds")
saveRDS(expr_count, "features/matrix.rds")

cat(crlf, green("successfully saved expression matrix."), crlf)

shared[["counts"]] <- expr_count
shared[["meta_sample_raw"]] <- sample_meta
shared[["meta_gene_raw"]] <- genes_meta
